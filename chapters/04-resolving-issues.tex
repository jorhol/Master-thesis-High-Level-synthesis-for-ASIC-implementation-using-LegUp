\chapter{Resolving issues with LegUp}
The main focuses of this project has been to resolve the issues encountered in \cite{holm2015pro}, to make LegUp able to generate Verilog more suited for ASIC implementation and synthesis. This chapter will describe the process of resolving these issues and other alterations that has been made in order to ease the creation of a framework for architectural exploration of hardware.
\section{Approach}
In the future works section of the project, two different approaches to resolve the issues were proposed; post-processing and pre-processing. Both approaches have been explored, but the main section of solutions are based on the pre-processing alternative. The two following subsection will present the two approaches and give some reasoning to why one is chosen over the other.
\subsection{Post-processing}
With the post-processing approach, the idea is to alter the Verilog-code after it is generated, to make it more suitable for our needs. This approach is easy to work with, as we can concentrate on a single file, the output Verilog file. The drawback of this approach is that you only have the information available in the Verilog file at hand, making it hard to add functionality to the tool.

There exist multiple parser tools for Verilog, for instance Verilog-Perl from VeriPool, a Verilog parser library for Perl, and pyverilog, a Hardware Design Processing Toolkit for Python \cite{Takamaeda2015Pyverilog}. These tools can be used to parse the Verilog file, to build module, signal, and port hierarchy, and easily add, alter, or remove objects.
\subsection{Pre-processing}
The pre-processing approach involves changing the libraries in LegUp that performes the HLS operations, like allocation, scheduling, RTL-generation and Verilog printing. This requires deep knowledge of the libraries and its connections, to be able to find a good way to change the output. The large libraries is the main drawback of this approach. As LegUp is open-source, the possibilities of this approach are however endless, but getting the necessary knowledge of the libraries takes time.
\subsection{The chosen approach}
As it looked like the easiest solution, the post-processing alternative were explored first. However, it were soon realised that the things that could be done easily with this approach, also could be done quite easily with the pre-processing approach. Some larger issues, for instance assigning values to outputs, were not easily solvable by using the post-processing method. The focus were therefore directed towards the pre-processing alternative.

\section{TCL commands}
LegUp uses TCL commands for setting constraints and configure the HLS process. In order to not clutter the original implementation, and to provide additional functionality to LegUp, some new commands were created. New TCL-parameters can easily be added to LegUp by adding the parameter name to the array \textit{validParameters} and increasing the parameter \textit{NUM\_PARAMETERS} in the file \textit{LegupConfig.cpp}. The value of the parameter can then be read using the function call \verb!LEGUP\_CONFIG->getParameter("\%parameterName\%")! to get a string, or \verb!LEGUP\_CONFIG->getParameterInt("\%parameterName\%")! to get an integer. LegupConfig.h must be included to get access to LEGUP\_CONFIG. The most common use of TCL-parameters are to check if a parameter is set, and perform some action if it is, or to use the parameter to set a variable. An example could be a parameter that decides if a designated top-module shall be generated or not. The parameter is define by adding the below line to the constraint file:

\begin{verbatim}
set_parameter PRINT_TOP_MODULE 1
\end{verbatim}
The parameter can then be used to decide if the Top-module should be printer:
\lstset{language=C++,style=Cstyle}
\begin{lstlisting}
  if(LEGUP_CONFIG->getParameterInt("PRINT_TOP_MODULE") {
    printTop();
  } else {
    printVerilogWithoutTop();
  }
\end{lstlisting}

Another example is to use a parameter to set the name of the top-module. This can be used either for naming the top-module, or to select top-module in the simulation-settings. 
\begin{verbatim}
set_parameter TOP_MODULE_NAME "moduleName"
\end{verbatim}
\begin{lstlisting}
  std::string topModuleName = "top"; // Default name
  if(LEGUP_CONFIG->getParameter("TOP_MODULE_NAME") {
    topModuleName = LEGUP_CONFIG->getParameter("TOP_MODULE_NAME");
  }
\end{lstlisting}
In the second example, the getParameter() function will return false if the parameter is not set.

Other TCL-commands can also be defined by adding 
\begin{lstlisting}
  Tcl_CreateCommand(interp,
                    "set_custom_main_function",
                    set_custom_main_function,
                    legupConfig,
                    0);
\end{lstlisting}
Where the second parameter is the TCL-command and the third parameter is the handler function that will be called when the TCL-command is encountered.

\begin{description}
\item{\textbf{ASIC\_IMPLEMENTATION}} \hfill \\
This parameter is used to distinguish between the standard version of LegUp and the altered version that will be used in this thesis for generating modules suitable for ASIC implementation. If this parameter is set, all extra features described in the following subsections will be applied to the generated design. If the parameter is not set, the unaltered edition of LegUp will be used to generate the output.
\item{\textbf{set\_custom\_main\_function}} \hfill \\
This parameter can be used to define inputs and outputs in the main module, as described in \cref{subsubsec:inoutparameter}. The  
\item{\textbf{ENCLOSING\_WHILE\_LOOP}} \hfill \\
Main-function has enclosing while loop (for streaming inputs/outputs). Will generate \textit{iterationFinish}-signal when iteration of while loop is finished,
\item{\textbf{SEPARATE\_TB\_FILE}} \hfill \\
Parameter decides if testbench is printed in same or a separate file. The filename of the separate testbench-file will be test\_main.v, according to Nordic's naming standard, but this can easily be changed or made dynamic by setting the constraint \textit{set\_custom\_testbench\_filename}.
\item{\textbf{SEPARATE\_TB\_FILENAME}} \hfill \\
Takes testbench filename as parameter and outputs testbench to a file with this name. Will not work if \textit{SEPARATE\_TB\_FILE} is not set. Default is \textit{test\_main.v}
\item{\textbf{TB\_TESTCASE\_FILE}} \hfill \\
As described in \cref{subsec:tbgen}, a way to automatically include testcases into the testbench is implemented. This parameter provides the filename of a file containg testcases for the testbench. If the parameter is not set, no testcases will be added to the testbench.
\item{\textbf{REMOVE\_UNUSED\_LOCAL\_RAMS}} \hfill \\
By declaring input parameters as volatile, a local RAM will be generated in the main module for each output signal we create. These RAMs is not used for anything useful and can therefore be removed to save area. If set, Local RAMs in main are removed \textit{if} the value stored to the RAM is assigned to an output instead.
\end{description}




\section{Removing memory controller}
One of the main issues with using LegUp for 

\section{\label{subsec:inoutdecl}Declaring inputs and outputs}
Each function declared in a C program will be translated into a Verilog-module by LegUp. Since LegUp primarily is designed for implementing hardware accelerators for FPGAs, it does not handle inputs and outputs well to and from the top module. In an ASIC implementation, inputs and outputs are essential to most module design and must therefore be easy to implement. In a C-program written for execution on a computer the input parameters to the main function is defined to be on the form "int main(int argc, char *argv[])". This limits the possibility to declare inputs to the module with any data-type. To solve this problem, the flag \textit{-ffreestanding} has to be passed to the clang compiler frontend of LLVM. The compiler will then consider the C-code to contain a freestanding - not a hosted - environment, and therefore not care about what types of inputs and return values the \textit{main}-function has. In LegUp, the flag can be passed to the compiler by adding it to the variable \textit{CLANG\_FLAG} in the file \textit{Makefile.config}.

The solution that would have been used in a hosted environment is to use pointers as input and output values as pass-by-reference.

Two different solutions for declaring inputs and outputs are considered and implemented. Both solutions are based on declaring both inputs and outputs as parameters to the main function.
\subsection{Name prefix}
The first solution is to use a prefix to distinguish between input and output parameters. To use a prefix that is seldom used in a variable name, the prefix is set to \textit{\_\_out\_}. Previously, LegUp assumed all function parameters were inputs, and added the signals to the RTLModule. This has been altered to check the name of the parameter and add it as an output reg if the name starts with \textit{\_\_out\_} or otherwise, add it as an input.

\begin{lstlisting}
std::string sigName = i->getName();
if (sigName.find("__out_") == 0) {
  sigName = sigName.substr(6, std::string::npos);
  i->setName(sigName);
  rtl->addOutReg(verilogName(i), RTLWidth(i->getType()));
  string validSigName = "arg_" + sigName + "_valid";
  rtl->addOutReg(validSigName);
} else {
  rtl->addIn(verilogName(i), RTLWidth(i->getType())); 
}
\end{lstlisting}
The advantage of this method is that it is easy to implement and easy to use, as the user only has to remember the name prefix when writing the functional specification. The name-prefix can also be useful in other sections of the program, as we will see later in section \ref{sec:assValueToOutput}. The disadvantage is that the name prefix needs to be used throughout the program. It would however be preferable to use a temporary variable in the program until the final value is calculated and ready to be assigned to the output. This will reduce the amount of times the name-prefix must be used.
The name prefix will be stripped by LegUp, making the signal in the final Verilog-module look much cleaner.
\subsection{\label{subsubsec:inoutparameter}TCL-command}
The other alternative is to declare in a TCL-command if each parameter is input or output. This also makes it possible to declare the size of the signal, but LegUp does not allow setting the size of the signals to a size lower than the size of what will be assigned to the signal.

The TCL-command \textit{set\_custom\_main\_function} described above, creates a vector with objects of the class CustomVerilogIO, each containing one input or output signal to the main module. The parameters can then be added as input or output to the RTLModule based on this information.
\begin{lstlisting}
std::vector<CustomVerilogIO> cmIO = LEGUP_CONFIG->getCustomMainIO();
for (std::vector<CustomVerilogIO>::iterator it = cmIO.begin();
     it != cmIO.end(); ++it) {

  CustomVerilogIO &cmIO = *it;

  if (cmIO.isInput && (cmIO.name == i->getName().str())) {
    rtl->addIn(verilogName(i),
               RTLWidth(cmIO.bitFrom, cmIO.bitTo));
  } else if (cmIO.name == i->getName().str()) {
    rtl->addOutReg(verilogName(i),
                   RTLWidth(cmIO.bitFrom, cmIO.bitTo));
  }
}
\end{lstlisting}

\section{\label{sec:assValueToOutput}Assigning values to outputs}
In \cref{subsec:inoutdecl} two methods of declaring parameters as outputs in the generated module were presented. Unfortunately, assigning values to a input parameter is undefined behaviour in C. This means that even though the compiler will generate LLVM IR that perform this operations, they are not handled in the LegUp backend pass that transforms the IR into Verilog. The result is that a signal declared as output is assigned to a local RAM module and no assignments to the output exists.

To overcome this issue, the idea to look at the LLVM IR code to see if any information about assignment could be gathered here and used in LegUp to assign the correct values to the output were brought up. 
\lstset{language=C,style=Cstyle}
\begin{lstlisting}[caption={Simple C-code example for LLVM IR parsing},label=lst:cllvmirparsercode]
void main(int inDataA, int inDataB, volatile int __out_outData) {
    while (1) {
        __out_outData = inDataA * inDataB;
    }
    return;
}
\end{lstlisting}
\lstset{language=LLVM,style=LLVMStyle}
\begin{lstlisting}[caption={LLVM IR code for simple parsing example},label=lst:llvmirparsercode]
define void @main(i32 %inDataA, i32 %inDataB, i32 %__out_outData) #0 {
  %1 = alloca i32, align 4
  store volatile i32 %__out_outData, i32* %1, align 4
  br label %2

; <label>:2                                       ; preds = %2, %0
  %3 = mul nsw i32 %inDataA, %inDataB
  store volatile i32 %3, i32* %1, align 4
  br label %2
                                                  ; No predecessors!
  ret void
}
\end{lstlisting}
Lets analyze the LLVM IR code output from compilation, shown in \cref{lst:llvmirparsercode}. On line 2 the temporary register \%1 is created. On line 3, the input parameter declared as volatile, \textit{\_\_out\_outData}, is stored to this register. On line 7, the multiplication calculation of the inputs inDataA and inDataB is stored to a new temporary register \%3. On line 8, the content of register \%3 is stored back to register \%1. This information can be exploited to create a program that traces stores, back to the original input parameter. In this example, we can easily see that the multiplication calculation easily can be traced back to the output \textit{\_\_out\_outData}, but in more complex programs, this tracing might not be that easily done. The solution would be to create a script that parses through the IR code and makes these connections for us. 

When LegUp generates signals, they will be named by the convention \%functionName\%\_\%labelNumber\%\_registerNumber\%. This means that the example above will create the signals (or RAM modules for parameters and arrays) \textit{main\_0\_1} from line 2 and \textit{main\_2\_3} from line 7.
\subsection{LLVM IR assignment parser program}
A program were created to parse the LLVM IR generated by the compilation. This section will explain in words and pseudo-code how the program works. The full source code of the parser program is included in \ref{lst:llvmirparserprogramcode} in the appendix. The program takes two command-line arguments when called, name of the input file and name of the output file. The input file should be the final LLVM IR file generated by LegUp, named \textit{\%designName\%.ll}. The output can be what you like, but the default file-name used in LegUp for reading of the output is \textit{LLVMParsed.log}. The program consist of two parts, the first part handles the reading and parsing of the input file, the second part is handling the generating of the output file. The program is created to only care about the main-function, as this is the module where it is vital to have multiple output signals. The program can easily be changed by altering the source code, if found necessary at a later point.

A pesudo-code describing the first part of the program is shown in \cref{alg:llvmparserpart1}. The parser starts by looking for the main-function. When in the main-function, the program looks for lines containing stores or labels. If a store is found, the source and target register of the store is stored in a vector, together with the current label. If a new label is found, the label is set as the current label.

\algnewcommand\algorithmicto{\textbf{to}}
\algnewcommand\algorithmicand{\textbf{and}}
\begin{algorithm}
  \caption{Pseudo-code of input file handling in LLVM IR parser program
  \label{alg:llvmparserpart1}}
  \begin{algorithmic}[1]
    \Require{inFile and outFile should be passed as arguments}
    \Statex
    \If{$inFile.open()$}
    \State $currentLabel \leftarrow 0$
    \State $inMain \leftarrow false$
      \While{$inFile.getNextLine() \neq inFile.end()$}
        \If{$inMain$}
          \If{$lineStartWith() = "~~store"$}
            \State $newSource \leftarrow sourceRegisterFromLine$
            \State $newTarget \leftarrow targetRegisterFromLine$
            \State $sources.insert(newSource)$
            \State $targets.insert(newTarget)$
            \State $labels.insert(currentLabel)$
          \ElsIf{$lineStartWith() = ";~<label>:"$}
            \State $currentLabel \leftarrow labelNumberFromLine$
          \ElsIf{$lineStartWith() = "\}"$}
            \State $inMain \leftarrow false$
          \EndIf
        \ElsIf{$lineStartWith() = "define~\%type\%~@main"$}
          \State $inMain \leftarrow true$
        \EndIf
      \EndWhile
    \EndIf
  \end{algorithmic}
\end{algorithm}
A pesudo-code describing the second part of the program is shown in \cref{alg:llvmparserpart2}. A double for-loop is needed to check each target against each other target. The C-example above will store the values shown in \cref{tab:llvmirparservectors} in the vectors. 
\begin{table}[hbtp]
    \centering
    \begin{tabular}{ccc}
    \textbf{sources} & \textbf{targets} & \textbf{labels} \\
    \toprule
      \_\_out\_outData & 1 & 0 \\
      3 & 1 & 2 \\
    \bottomrule
    \end{tabular}
    \caption{Caption}
    \label{tab:llvmirparservectors}
\end{table}
By comparing the first target against the second target in the table, it can easily be seen that the second source is stored to the same target as the first source. The output format is given by:
\verb!"sources[i] sources[j] labels[j] labels[i] targets[i]"!
The output from the above example will then be:
\verb!"outData 3 2 0 1"!.
This implies that the signal \textit{main\_2\_3} should be assigned to the output \textit{outData}. The two last values, 0 and 1, are included as they will be used in a trick in \cref{subsec:assigningoutputsignals} to simplify the process of assigning signals to output ports.
\begin{algorithm}
  \caption{Pseudo-code of output file handling in LLVM IR parser program
  \label{alg:llvmparserpart2}}
  \begin{algorithmic}[1]
    \If{$outFile.open()$}
    \State $done \leftarrow \{\}$
      \For{$i \leftarrow 0~\algorithmicto~targets.size()$}
        \For{$j \leftarrow 0~\algorithmicto~targets.size()$}
          \If{$targets[i] = targets[j]~\algorithmicand~i \neq j~\algorithmicand~sources[i] \notin done$}
            \State $newSource \leftarrow sourceRegisterFromLine$
            \State $newTarget \leftarrow targetRegisterFromLine$
            \State $done.insert(sources[j])$
            \If{$sources[i].lineStartWith() = "\_\_out\_"$}
              \State $parameterName \leftarrow sources[i].strip(\_\_out\_)$
              \State $outFile.print(parameterName)$
              \State $outFile.print(sources[j])$
              \State $outFile.print(labels[j])$
              \State $outFile.print(labels[i])$
              \State $outFile.print(targets[i])$
              \State $outFile.print("\backslash n")$ \Comment{$Newline$}
            \EndIf
          \EndIf
        \EndFor
      \EndFor
    \EndIf
  \end{algorithmic}
\end{algorithm}
Execution of the program is added to the common Makefile, \textit{Makefile.common}, just before running the LegUp backend pass that generated Verilog output. The program is called by the line:
\begin{verbatim}
$(LEVEL)/LlvmParser.run $(NAME).ll LlvmParsed.log
\end{verbatim}

\subsection{\label{subsec:assigningoutputsignals}Assigning output signals}
As described in \cref{sec:legupclasses}, any RTLSignal that exist in an RTLModule can be found by calling the function \textit{find()}, with the name of the signal passed as a string parameter. A RTLSignal can have multiple drivers and conditions, and the i-th driver or condition can be found by calling getDriver(i) and getCondition(i). The initial idea when the LLVM IR parser program was created, was to find each of the signal and connect it to the correct output.

For every parameter to the function, the compiler will allocate a register and store the parameter value to this register. Whenever a store to a parameter is performed, this value will be stored to the first allocated register. In LegUp, the allocated register will be implemented as a RAM module and all stores to the parameter will be stored to this ram. This information can be exploited to easily assign values stored to this RAM to the output port instead.

\begin{figure}
        \centering
        \begin{subfigure}{0.49\textwidth}\centering%no!\hfill
                    \includegraphics[width=\linewidth]{figs/OutputAssignment1.png}
                \caption{What we want to achieve}
  \label{fig:assignoutputs1}
       \end{subfigure}%
%no, don't use ~!           ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
      %(or a blank line to force the subfigure onto a new line)
    \hfill
        \begin{subfigure}{0.49\textwidth}\centering
                    \includegraphics[width=\linewidth]{figs/OutputAssignment2.png}
                \caption{What the compiler/Legup thinks we want to achieve}
  \label{fig:assignoutputs2}
       \end{subfigure}%
    \hfill
        \begin{subfigure}{0.49\textwidth}\centering
                    \includegraphics[width=\linewidth]{figs/OutputAssignment3.png}
                \caption{An example with multiple stores to \textit{outData}}
  \label{fig:assignoutputs3}
       \end{subfigure}%
    \hfill
        \begin{subfigure}{0.49\textwidth}\centering
                    \includegraphics[width=\linewidth]{figs/OutputAssignment4.png}
                \caption{The solution}
  \label{fig:assignoutputs4}
       \end{subfigure}%

\caption{4 figures}
\label{fig:assigningoutputs}
 \end{figure}
\cref{fig:assigningoutputs} tries to illustrate the problem with assigning outputs. In \cref{fig:assignoutputs1}, the module we would expect from the C-code in \cref{} is shown. The two inputs are multiplied together and output to outData. In reality, what happens in the generated Verilog is shown in \cref{fig:assignoutputs2} and in \cref{fig:assignoutputs3}, when extended with an extra ADD module that stores to \textit{outData}. Instead of assigning the calculated values to the output, they are stored in a RAM module. The solution to this problem is shown in \cref{fig:assignoutputs4}. By "hijacking" the input signal to the RAM module and assigning it to the output, \textit{outData}, we get the expected functionality. 

The RAM module will be named by the same convention as signals, naming the RAM in this module \textit{main\_0\_1}. The dataIn signal of the RAM module is named \%ramName\%\_in\_a. This is the signal we want to "hijack". The "hijacking" is performed as described in \cref{alg:assignoutputsignals}. The name of the output ports are read from the file output from the LLVM IR parser program, together with the name of the corresponding RAM modules. For every output port, each driver-condition pair stored to the RAM module is added as a conditional driver to the output port.
\makeatletter
\let\OldStatex\Statex
\renewcommand{\Statex}[1][3]{%
  \setlength\@tempdima{\algorithmicindent}%
  \OldStatex\hskip\dimexpr#1\@tempdima\relax}
\makeatother
\begin{algorithm}
  \caption{Pseudo-code of assigning values to outputs
  \label{alg:assignoutputsignals}}
  \begin{algorithmic}[1]
    \For{$i \leftarrow 0~\algorithmicto~outputPorts.size()$}
      \State $outputPort \gets find(output~signal~name)$
      \State $ramSignal \gets find(RAM~module~inData~signal)$
      \For{$j \gets 0~\algorithmicto~ramSignal.getNumDrivers()$}
        \State $outputPort.addCondition(ramSignal.getDriver(j),$
        \Statex[9] $~~~~ramSignal.getCondition(j))$
      \EndFor
    \EndFor
  \end{algorithmic}
\end{algorithm}

\subsection{Removing local RAMs}
After reassigning the RAM stores to the output port, the generated RAM module corresponding to the input parameters are no longer needed. The ram modules can be removed to save area and power consumption. To make this operation optional, the TCL-parameter \textit{REMOVE\_UNUSED\_LOCAL\_RAMS} were added. By setting this parameter, the local RAM modules will be removed. All RAMs local to a module is stored together with its corresponding function (from the C-code) in a variable, \textit{	isLocalFunctionRam}. When the RAM is removed, it is simply removed from this variable. In addition to removing the RAM module, all signals to and from the RAM needs to be removed as well. Notice that only the RAMs generated by output parameters are removed from the main module. RAM modules can also be generated by arrays and other large data structures, but these will not be removed in any cases.

\section{Streaming inputs/outputs}
For most module designs to be useful, fast and , it must be able to continuously take new inputs and generate outputs, without having to start and stop the entire module each time, with all the overhead in time this would require. The way LegUp is designed, functions are used as hardware accelerators, meaning it gets some input, performs some calculations and the outputs the result. The module is then finished and will not run again until next time the accelerated function is called. For this approach to work for an ASIC implementation, a top module would need to be created to assign new inputs and start the module again once it is finished with the last iteration. This would create a lot of unwanted overhead, both in size and speed. A better solution would therefore be to add a while loop inside the main function of the C program to make the program run continuously.

With this solution some new issues arise. 
First we need a way to stop the module if all calculations are finished. This can easily be handled by adding a input parameter to the main function in the C-program, lets call it done, which is used as condition for running the while-loop. This parameter will then correspond to a signal in the Verilog-module that can be used to terminate the module. No alterations to LegUp is performed to resolve this issue, as it can be resolved manually by the user. This signal could not be added by LegUp, as it would require major alterations to the generated data-flow.

Secondly, we need a way to know when an output has valid data. A simple solution here is to generate a valid-flag for each output signal. These flags are created simultaneously with the outputs being connected to the driving signals, as described in \ref{sec:assValueToOutput}. The signals shall be valid only in the first clock cycle after the output signal has changed. To achieve this, two condition signals has to be created, one when the output is valid, and one when the output is not valid. The valid condition shall be set in any state where the output signal is assigned, i.e. the conditions gathered from the RAM module \textit{dataIn}-signal, and not valid in all other states. To create the valid-signal is straightforward, by adding the conditions from the RAM signal. To create the not valid signal are a bit more tricky. By creating an RTLOp-signal, AND-ing together all the valid states, and creating a second RTLOp-signal NOT-ing the first RTLOp signal, we will have the desired signals. The tricky part arises from the AND operation only being able to take two operands, making it hard to create code handling special cases of few and odd number of valid states. The source code of how this is handled is included in \cref{sec:validsinglssourcecode}.

The third and final issue we need to handle is that we need a way t know when an iteration of the loop is finished. This \textit{iterationFinish}-flag should be set in the state preceding the final state of the FSM.
\lstset{language=C,style=Cstyle}
\definecolor{LightGray}{gray}{0.9}
\begin{listing}[ht]
\begin{minted}
[
breaklines,
%frame=lines,
frame=single,
%framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos,
tabsize=2,
]
{cpp}
RTLSignal *interationFinish = rtl->addOutReg("interationFinish");

connectSignalToDriverInState(interationFinish, ONE, (--fsm->end())->getPrevNode());
interationFinish->addCondition(rtl->addOp(RTLOp::Not)->setOperands(interationFinish ->getCondition(0)), ZERO);
\end{minted}
\caption{Example with line numbers enabled}
\end{listing}
\begin{lstlisting}
RTLSignal *interationFinish = rtl->addOutReg("interationFinish");

connectSignalToDriverInState(interationFinish, ONE, (--fsm->end())->getPrevNode());
interationFinish->addCondition(rtl->addOp(RTLOp::Not)->setOperands(interationFinish->getCondition(0)), ZERO);
\end{lstlisting}
\begin{lstlisting}[caption={FIR-filter implemented in C},label=lst:firfilterc]
void main( int done ) {
  // Variable setup etc. can be done here.
  while(done == 0) {
    // Module operations are performed here
  }
  // No operations can be done here.
  return;
}
\end{lstlisting}

\section{\label{subsec:tbgen}Testbench generation}
LegUp did generate a basic testbench shell, but this were very static and incorporated into the same file as the module design, making it impractical to use in Nordic's toolflow. The generated testbench consisted of a testbench module, main\_tb, which instantiate the top module, \textit{top}, and sets reset, start and waitrequest flags. The input and output signals in the top module does not contain custom signals from the main module, and in an ASIC implementation we are not interested in the memory controller and additional modules declared/instantiated in the top module. The solution then, became to instantiate the main module instead and add each input or output by iterating over the ports in the main module.

\begin{lstlisting}
RTLModule *t = m->addModule("main", "main_inst");
if (LEGUP_CONFIG->getParameterInt("ASIC_IMPLEMENTATION")) {
  RTLModule *rtl = alloc->getModuleForFunction(alloc->getModule()->getFunction("main"));
  if (rtl->getName().compare("main") == 0) {
    for (RTLModule::const_signal_iterator i = rtl->port_begin(), e = rtl->port_end(); i != e; ++i) {
      const RTLSignal *s = *i;
      RTLSignal *d;
      string type = s->getType();
      if (!type.empty()) {
        if (type.compare(0, 6, "output") == 0) {
          d = m->addWire(s->getName(), s->getWidth());
          t->addOut(s->getName(), s->getWidth())->connect(d);
        } else {
          d = m->addReg(s->getName(), s->getWidth());
          t->addIn(s->getName(), s->getWidth())->connect(d);
        }
      }
    }
  }
}
\end{lstlisting}

As the testbench does not come with any form of testcases or applied signals, the testbench generater is extended to input Verilog code from a file specified by the TCL-parameter \textit{TB\_TESTCASE\_FILE}. This allows the user to specify testcases in this file, and it will automatically be inserted into the testbench file inside the testbench module. The code will be placed inside the module, but not inside any procedural blocks. This allows the user to add the preferred procedural block in the specified testcase file. An example testcase file can then be:

\lstset{language=Verilog, style=Verilogstyle}
\begin{lstlisting}
always @(iterationFinish) begin
  if (iterationFinish == 1) begin
    $display("At t=%t, Loop iteration finished", $time);
  end
end
\end{lstlisting}
or
\begin{lstlisting}
initial begin
    inData <= 100;
    @(posedge clk)
    inData <= 0;
    @(posedge clk);
    $display("At t=%t, outData=%d", $time, outData);
end
\end{lstlisting}
This automatic insertion of testcases, enables the script to first run HLS and then run simulation on the generated design and testbench.

\section{Coding constraints}
Due to some alterations made to the LegUp libraries, some additional constraints need to be followed when writing the functional specification to ensure correct output. The following subsections will describe these constraints.
\subsection{Structs}
To support structs, byte-enable must be supported by the RAM or ROM module used to store the data. The RAM and ROM modules inferred by LegUp does not support byte-enable, resulting in struct support not being present when writing the functional specification. If structs are used in the code, LegUp will use an altsyncram-module instead of inferring RAMs. The altsyncram-module is not supported by the IC-compiler toolflow used at Nordic for synthesis, and inferred RAM-modules must therefore be used. 
\subsection{Pointers}
Pointers are used to reference an object in memory, opposed to passing a copy of the actual object between function. This reduces both CPU-time and memory-space, as objects does not need to be copied every time it is used, and makes it possible to alter a memory object directly without implicit load and store operations. As the memory controller used to pass data between different modules are unwanted in an ASIC implementation, support for pointers are limited to use inside the function where the pointer is declared. This limitation is a big drawback with the additions to LegUp.
