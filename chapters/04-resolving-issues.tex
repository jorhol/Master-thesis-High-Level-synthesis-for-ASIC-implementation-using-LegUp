\chapter{Resolving issues with LegUp}
The main focuses of this project has been to resolve the issues encountered in \cite{holm2015pro}, to make LegUp able to generate Verilog more suited for ASIC implementation and synthesis. This chapter will describe the process of resolving these issues and other alterations that has been made in order to ease the creation of a framework for architectural exploration of hardware.
\section{Approach}
In the future works section of the project, two different approaches to resolve the issues were proposed; post-processing and pre-processing. Both approaches have been explored, but the main section of solutions are based on the pre-processing alternative. The two following subsection will present the two approaches and give some reasoning to why one is chosen over the other.
\subsection{Post-processing}
With the post-processing approach, the idea is to alter the Verilog-code after it is generated, to make it more suitable for our needs. This approach is easy to work with, as we can concentrate on a single file, the output Verilog file. The drawback of this approach is that you only have the information available in the Verilog file at hand, making it hard to add functionality to the tool.

There exist multiple parser tools for Verilog, for instance Verilog-Perl from VeriPool, a Verilog parser library for Perl, and pyverilog, a Hardware Design Processing Toolkit for Python \cite{Takamaeda2015Pyverilog}. These tools can be used to parse the Verilog file, to build module, signal, and port hierarchy, and easily add, alter, or remove objects.
\subsection{Pre-processing}
The pre-processing approach involves changing the libraries in LegUp that performes the HLS operations, like allocation, scheduling, RTL-generation and Verilog printing. This requires deep knowledge of the libraries and its connections, to be able to find a good way to change the output. The large libraries is the main drawback of this approach. As LegUp is open-source, the possibilities of this approach are however endless, but getting the necessary knowledge of the libraries takes time.
\subsection{The chosen approach}
As it looked like the easiest solution, the post-processing alternative were explored first. However, it were soon realised that the things that could be done easily with this approach, also could be done quite easily with the pre-processing approach. Some larger issues, for instance assigning values to outputs, were not easily solvable by using the post-processing method. The focus were therefore directed towards the pre-processing alternative.

\section{TCL commands}
LegUp uses TCL commands for setting constraints and configure the HLS process. In order to not clutter the original implementation, and to provide additional functionality to LegUp, some new commands were created. New TCL-parameters can easily be added to LegUp by adding the parameter name to the array \textit{validParameters} and increasing the parameter \textit{NUM\_PARAMETERS} in the file \textit{LegupConfig.cpp}. The value of the parameter can then be read using the function call \verb!LEGUP\_CONFIG->getParameter("\%parameterName\%")! to get a string, or \verb!LEGUP\_CONFIG->getParameterInt("\%parameterName\%")! to get an integer. LegupConfig.h must be included to get access to LEGUP\_CONFIG. The most common use of TCL-parameters are to check if a parameter is set, and perform some action if it is, or to use the parameter to set a variable. An example could be a parameter that decides if a designated top-module shall be generated or not. The parameter is define by adding the below line to the constraint file:

\begin{verbatim}
set_parameter PRINT_TOP_MODULE 1
\end{verbatim}
The parameter can then be used to decide if the Top-module should be printer:
\lstset{language=C++,style=Cstyle}
\begin{lstlisting}
  if(LEGUP_CONFIG->getParameterInt("PRINT_TOP_MODULE") {
    printTop();
  } else {
    printVerilogWithoutTop();
  }
\end{lstlisting}

Another example is to use a parameter to set the name of the top-module. This can be used either for naming the top-module, or to select top-module in the simulation-settings. 
\begin{verbatim}
set_parameter TOP_MODULE_NAME "moduleName"
\end{verbatim}
\begin{lstlisting}
  std::string topModuleName = "top"; // Default name
  if(LEGUP_CONFIG->getParameter("TOP_MODULE_NAME") {
    topModuleName = LEGUP_CONFIG->getParameter("TOP_MODULE_NAME");
  }
\end{lstlisting}
In the second example, the getParameter() function will return false if the parameter is not set.

Other TCL-commands can also be defined by adding 
\begin{lstlisting}
  Tcl_CreateCommand(interp,
                    "set_custom_main_function",
                    set_custom_main_function,
                    legupConfig,
                    0);
\end{lstlisting}
Where the second parameter is the TCL-command and the third parameter is the handler function that will be called when the TCL-command is encountered.

\begin{description}
\item{\textbf{ASIC\_IMPLEMENTATION}} \hfill \\
This parameter is used to distinguish between the standard version of LegUp and the altered version that will be used in this thesis for generating modules suitable for ASIC implementation. If this parameter is set, all extra features described in the following subsections will be applied to the generated design. If the parameter is not set, the unaltered edition of LegUp will be used to generate the output.
\item{\textbf{set\_custom\_main\_function}} \hfill \\
This parameter can be used to define inputs and outputs in the main module, as described in \cref{subsubsec:inoutparameter}. The  
\item{\textbf{ENCLOSING\_WHILE\_LOOP}} \hfill \\
Main-function has enclosing while loop (for streaming inputs/outputs). Will generate \textit{iterationFinish}-signal when iteration of while loop is finished,
\item{\textbf{SEPARATE\_TB\_FILE}} \hfill \\
Parameter decides if testbench is printed in same or a separate file. The filename of the separate testbench-file will be test\_main.v, according to Nordic's naming standard, but this can easily be changed or made dynamic by setting the constraint \textit{set\_custom\_testbench\_filename}.
\item{\textbf{SEPARATE\_TB\_FILENAME}} \hfill \\
Takes testbench filename as parameter and outputs testbench to a file with this name. Will not work if \textit{SEPARATE\_TB\_FILE} is not set. Default is \textit{test\_main.v}
\item{\textbf{TB\_TESTCASE\_FILE}} \hfill \\
As described in \cref{subsec:tbgen}, a way to automatically include testcases into the testbench is implemented. This parameter provides the filename of a file containg testcases for the testbench. If the parameter is not set, no testcases will be added to the testbench.
\item{\textbf{REMOVE\_UNUSED\_LOCAL\_RAMS}} \hfill \\
By declaring input parameters as volatile, a local RAM will be generated in the main module for each output signal we create. These RAMs is not used for anything useful and can therefore be removed to save area. If set, Local RAMs in main are removed \textit{if} the value stored to the RAM is assigned to an output instead.
\end{description}




\subsection{Removing memory controller}
One of the main issues with using LegUp for 

\subsection{\label{subsec:inoutdecl}Declaring inputs and outputs}
Each function declared in a C program will be translated into a Verilog-module by LegUp. Since LegUp primarily is designed for implementing hardware accelerators for FPGAs, it does not handle inputs and outputs well to and from the top module. In an ASIC implementation, inputs and outputs are essential to most module design and must therefore be easy to implement. In a C-program written for execution on a computer the input parameters to the main function is defined to be on the form "int main(int argc, char *argv[])". This limits the possibility to declare inputs to the module with any data-type. To solve this problem, the flag \textit{-ffreestanding} has to be passed to the clang compiler frontend of LLVM. The compiler will then consider the C-code to contain a freestanding - not a hosted - environment, and therefore not care about what types of inputs and return values the \textit{main}-function has. In LegUp, the flag can be passed to the compiler by adding it to the variable \textit{CLANG\_FLAG} in the file \textit{Makefile.config}.

The solution that would have been used in a hosted environment is to use pointers as input and output values as pass-by-reference.

Two different solutions for declaring inputs and outputs are considered and implemented. Both solutions are based on declaring both inputs and outputs as parameters to the main function.
\subsubsection{Name prefix}
The first solution is to use a prefix to distinguish between input and output parameters. To use a prefix that is seldom used in a variable name, the prefix is set to \textit{\_\_out\_}. Previously, LegUp assumed all function parameters were inputs, and added the signals to the RTLModule. This has been altered to check the name of the parameter and add it as an output reg if the name starts with \textit{\_\_out\_} or otherwise, add it as an input.

\begin{lstlisting}
std::string sigName = i->getName();
if (sigName.find("__out_") == 0) {
  sigName = sigName.substr(6, std::string::npos);
  i->setName(sigName);
  rtl->addOutReg(verilogName(i), RTLWidth(i->getType()));
  string validSigName = "arg_" + sigName + "_valid";
  rtl->addOutReg(validSigName);
} else {
  rtl->addIn(verilogName(i), RTLWidth(i->getType())); 
}
\end{lstlisting}
The advantage of this method is that it is easy to implement and easy to use, as the user only has to remember the name prefix when writing the functional specification. The name-prefix can also be useful in other sections of the program, as we will see later in section \ref{sec:assValueToOutput}. The disadvantage is that the name prefix needs to be used throughout the program. It would however be preferable to use a temporary variable in the program until the final value is calculated and ready to be assigned to the output. This will reduce the amount of times the name-prefix must be used.
The name prefix will be stripped by LegUp, making the signal in the final Verilog-module look much cleaner.
\subsubsection{\label{subsubsec:inoutparameter}TCL-command}
The other alternative is to declare in a TCL-command if each parameter is input or output. This also makes it possible to declare the size of the signal, but LegUp does not allow setting the size of the signals to a size lower than the size of what will be assigned to the signal.

The TCL-command \textit{set\_custom\_main\_function} described above, creates a vector with objects of the class CustomVerilogIO, each containing one input or output signal to the main module. The parameters can then be added as input or output to the RTLModule based on this information.
\begin{lstlisting}
std::vector<CustomVerilogIO> cmIO = LEGUP_CONFIG->getCustomMainIO();
for (std::vector<CustomVerilogIO>::iterator it = cmIO.begin();
     it != cmIO.end(); ++it) {

  CustomVerilogIO &cmIO = *it;

  if (cmIO.isInput && (cmIO.name == i->getName().str())) {
    rtl->addIn(verilogName(i),
               RTLWidth(cmIO.bitFrom, cmIO.bitTo));
  } else if (cmIO.name == i->getName().str()) {
    rtl->addOutReg(verilogName(i),
                   RTLWidth(cmIO.bitFrom, cmIO.bitTo));
  }
}
\end{lstlisting}

\subsection{\label{sec:assValueToOutput}Assigning values to outputs}
In \cref{subsec:inoutdecl} two methods of declaring parameters as outputs in the generated module were presented. Unfortunately, assigning values to a input parameter is undefined behaviour in C. This means that even though the compiler will generate LLVM IR that perform this operations, they are not handled in the LegUp backend pass that transforms the IR into Verilog. The result is that a signal declared as output is assigned to a local RAM module and no assignments to the output exists.

To overcome this issue, the idea to look at the LLVM IR code to see if any information about assignment could be gathered here and used in LegUp to assign the correct values to the output were brought up. 
\lstset{language=C,style=Cstyle}
\begin{lstlisting}[caption={},label=lst:cllvmirparsercode]
void main(int inDataA, int inDataB, volatile int __out_outData) {
    while (1) {
        __out_outData = inDataA * inDataB;
    }
    return;
}
\end{lstlisting}
\lstset{language=LLVM,style=LLVMStyle}
\begin{lstlisting}[caption={},label=lst:llvmirparsercode]
define void @main(i32 %inDataA, i32 %inDataB, i32 %__out_outData) #0 {
  %1 = alloca i32, align 4
  store volatile i32 %__out_outData, i32* %1, align 4
  br label %2

; <label>:2                                       ; preds = %2, %0
  %3 = mul nsw i32 %inDataA, %inDataB
  store volatile i32 %3, i32* %1, align 4
  br label %2
                                                  ; No predecessors!
  ret void
}
\end{lstlisting}
Lets analyze the LLVM IR code output from compilation, shown in \cref{lst:llvmirparsercode}. On line 2 the temporary register \%1 is created. On line 3, the input parameter declared as volatile, \textit{\_\_out\_outData}, is stored to this register. On line 7, the multiplication calculation of the inputs inDataA and inDataB is stored to a new temporary register \%3. On line 8, the content of register \%3 is stored back to register \%1. This information can be exploited to create a program that traces stores, back to the original input parameter. In this example, we can easily see that the multiplication calculation easily can be traced back to the output \textit{\_\_out\_outData}, but in more complex programs, this tracing might not be that easily done. The solution would be to create a script that parses through the IR code and makes these connections for us. 

When LegUp generates signals, they will be named by the convention \%functionName\%\_\%labelNumber\%\_registerNumber\%. This means that the example above will create the signals (or RAM modules for parameters and arrays) \textit{main\_0\_1} from line 2 and \textit{main\_2\_3} from line 7.
\subsubsection{LLVM IR assignment parser program}
A program were created to parse the LLVM IR generated by the compilation. The full source code of the parser program is listed in \ref{lst:llvmirparserprogramcode}, but 

\begin{algorithm}
  \caption{Counting mismatches between two packed strings
  \label{alg:packed-dna-hamming}}
  \begin{algorithmic}[1]
    \Require{inFile and outFile should be passed as arguments}
    \Statex
    \If{$inFile.open()$}
    \State $currentLabel \leftarrow 0$
    \State $inMain \leftarrow false$
      \While{$inFile.getNextLine() \neq inFile.end()$}
        \If{$in~main-function~block$}
          \If{$lineStartWith() = "~~store"$}
            \State $newSource \leftarrow sourceRegisterFromLine$
            \State $newTarget \leftarrow targetRegisterFromLine$
            \State $sources.push\_back(newSource)$
            \State $targets.push\_back(newTarget)$
            \State $labels.push\_back(currentLabel)$
          \ElsIf{$lineStartWith() = ";~<label>:"$}
            \State $currentLabel \leftarrow labelNumberFromLine$
          \EndIf
        \ElsIf{$lineStartWith() = "define~\%type\%~@main"$}
          \State $inMain \leftarrow true$
        \EndIf
      \EndWhile
    \EndIf
    \If{$outFile.open()$}
    \State $done \leftarrow false$
      \For{$i=0 to targets.end()$}
        \For{$j=0 to targets.end()$}
          \If{$targets[i] = targets[j] \and i \neq j$}
          \If{$lineStartWith() = "~~store"$}
            \State $newSource \leftarrow sourceRegisterFromLine$
            \State $newTarget \leftarrow targetRegisterFromLine$
            \State $sources.push\_back(newSource)$
            \State $targets.push\_back(newTarget)$
            \State $labels.push\_back(currentLabel)$
          \ElsIf{$lineStartWith() = ";~<label>:"$}
            \State $currentLabel \leftarrow labelNumberFromLine$
          \EndIf
        \ElsIf{$lineStartWith() = "define~\%type\%~@main"$}
          \State $inMain \leftarrow true$
        \EndIf
      \EndWhile
    \EndIf
      \State outFile
      \State \Return{$0$}
  \end{algorithmic}
\end{algorithm}
\subsection{Streaming inputs/outputs}
For most module designs to be useful, fast and , it must be able to continuously take new inputs and generate outputs, without having to start and stop the entire module each time, with all the overhead in time this would require. The way LegUp is designed, functions are used as hardware accelerators, meaning it gets some input, performs some calculations and the outputs the result. The module is then finished and will not run again until next time the accelerated function is called. For this approach to work for an ASIC implementation, a top module would need to be created to assign new inputs and start the module again once it is finished with the last iteration. This would create a lot of unwanted overhead, both in size and speed. A better solution would therefore be to add a while loop inside the main function of the C program to make the program run continuously.

With this solution some new issues arise. 
First we need a way to stop the module if all calculations are finished. This can easily be handled by adding a input parameter to the main function in the C-program, lets call it done, which is used as condition for running the while-loop. This parameter will then correspond to a signal in the Verilog-module that can be used to terminate the module. No alterations to LegUp is performed to resolve this issue, as it can be resolved manually by the user. This signal could not be added by LegUp, as it would require major alterations to the generated data-flow.

Secondly, we need a way to know when an output has valid data. A simple solution here is to generate a valid-flag for each output signal. These flags are created simultaneously with the outputs connected to the driving signals, as described in \ref{sec:assValueToOutput}.

The third and final issue we need to handle is that we need a way t know when an iteration of the loop is finished. This \textit{iterationFinish}-flag should be set in the state preceding the final state of the FSM.
\lstset{language=C,style=Cstyle}
\begin{lstlisting}
RTLSignal *interationFinish = rtl->addOutReg("interationFinish");

connectSignalToDriverInState(interationFinish, ONE, (--fsm->end())->getPrevNode());
interationFinish->addCondition(rtl->addOp(RTLOp::Not)->setOperands(interationFinish->getCondition(0)), ZERO);
\end{lstlisting}
\begin{lstlisting}[caption={FIR-filter implemented in C},label=lst:firfilterc]
void main( int done ) {
  // Variable setup etc. can be done here.
  while(done == 0) {
    // Module operations are performed here
  }
  // No operations can be done here.
  return;
}
\end{lstlisting}

\subsection{\label{subsec:tbgen}Testbench generation}
LegUp did generate a basic testbench shell, but this were very static and incorporated into the same file as the module design, making it impractical to use in Nordic's toolflow. The generated testbench consisted of a testbench module, main\_tb, which instantiate the top module, \textit{top}, and sets reset, start and waitrequest flags. The input and output signals in the top module does not contain custom signals from the main module, and in an ASIC implementation we are not interested in the memory controller and additional modules declared/instantiated in the top module. The solution then, became to instantiate the main module instead and add each input or output by iterating over the ports in the main module.

\begin{lstlisting}
RTLModule *t = m->addModule("main", "main_inst");
if (LEGUP_CONFIG->getParameterInt("ASIC_IMPLEMENTATION")) {
  RTLModule *rtl = alloc->getModuleForFunction(alloc->getModule()->getFunction("main"));
  if (rtl->getName().compare("main") == 0) {
    for (RTLModule::const_signal_iterator i = rtl->port_begin(), e = rtl->port_end(); i != e; ++i) {
      const RTLSignal *s = *i;
      RTLSignal *d;
      string type = s->getType();
      if (!type.empty()) {
        if (type.compare(0, 6, "output") == 0) {
          d = m->addWire(s->getName(), s->getWidth());
          t->addOut(s->getName(), s->getWidth())->connect(d);
        } else {
          d = m->addReg(s->getName(), s->getWidth());
          t->addIn(s->getName(), s->getWidth())->connect(d);
        }
      }
    }
  }
}
\end{lstlisting}

As the testbench does not come with any form of testcases or applied signals, the testbench generater is extended to input Verilog code from a file specified by the TCL-parameter \textit{TB\_TESTCASE\_FILE}. This allows the user to specify testcases in this file, and it will automatically be inserted into the testbench file inside the testbench module. The code will be placed inside the module, but not inside any procedural blocks. This allows the user to add the preferred procedural block in the specified testcase file. An example testcase file can then be:

\lstset{language=Verilog, style=Verilogstyle}
\begin{lstlisting}
always @(iterationFinish) begin
  if (iterationFinish == 1) begin
    $display("At t=%t, Loop iteration finished", $time);
  end
end
\end{lstlisting}
or
\begin{lstlisting}
initial begin
    inData <= 100;
    @(posedge clk)
    inData <= 0;
    @(posedge clk);
    $display("At t=%t, outData=%d", $time, outData);
end
\end{lstlisting}
This automatic insertion of testcases, enables the script to first run HLS and then run simulation on the generated design and testbench.

\section{Coding constraints}
Due to some alterations made to the LegUp libraries, some additional constraints need to be followed when writing the functional specification to ensure correct output. The following subsections will describe these constraints.
\subsection{Structs}
To support structs, byte-enable must be supported by the RAM or ROM module used to store the data. The RAM and ROM modules inferred by LegUp does not support byte-enable, resulting in struct support not being present when writing the functional specification. If structs are used in the code, LegUp will use an altsyncram-module instead of inferring RAMs. The altsyncram-module is not supported by the IC-compiler toolflow used at Nordic for synthesis, and inferred RAM-modules must therefore be used. 
\subsection{Pointers}
Pointers are used to reference an object in memory, opposed to passing a copy of the actual object between function. This reduces both CPU-time and memory-space, as objects does not need to be copied every time it is used, and makes it possible to alter a memory object directly without implicit load and store operations. As the memory controller used to pass data between different modules are unwanted in an ASIC implementation, support for pointers are limited to use inside the function where the pointer is declared. This limitation is a big drawback with the additions to LegUp.
\subsection{}
