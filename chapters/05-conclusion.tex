\chapter{Conclusion}
\label{chp:conclusion} 
This report has presented the \gls{hls}-tool, LegUp, and shown how it potentially can be used in a framework for architectural exploration of digital hardware toward \gls{asic} applications. A specification of a framework that can be used to automate the process of architectural exploration have been presented. Unfortunately, multiple problems were encountered along the way. Identifying and attempting to resolve these problems required a lot of time, which took the focus away from the main objectives. The outcome of this, is that no results from comparison between hand-written Verilog and \gls{hls} generated Verilog are presented. The implementations of the designs are still presented, making it an easy task to do the comparison once the encountered problems are sorted out.

In its current state, LegUp cannot be used as a tool for architectural exploration of digital hardware in the context of \gls{asic} applications. For this, it has too many elementary deficiencies which are required when designing hardware for an \gls{asic} implementation. If LegUp can be used for our initial intentions, cannot be concluded until the presented issues have been resolved and a larger "proof-of-concept"-study has been conducted. The major advantage LegUp has is that it is open-source and thus, it has the potential to become whatever you want it to be - given that you have time to do it yourself. However, it is important to remember that transforming a tool into something it is not intended for, might be more time-consuming than creating what you need from scratch.

The following section will present future work for an eventual continuation of the project. Some fundamental issues that needs attention are described firstly. The issues are followed by two proposed approaches to eliminate the problems, and solutions for some of the issues for each approach. Finally, a list of further extensions are included. These extensions are not vital for the use of LegUp in an architectural exploration framework, but they add functionality that any designer would cherish.
\section{Future work}
\label{sec:futurework} 


\subsection{Required actions}
\label{subsec:reqact}
If this project should be extended into a master thesis or project at a later stage, the following issues needs to be handled:
\begin{enumerate}
    \item \label{item:futworkprob}The Clang frontend in LLVM, used by LegUP for compilation of the C-source code, needs to be altered so that the list of input variables and return values in the \textit{main}-function of the C program can be of other formats than the standard \textit{int main(int argc, char *argv[])}.
    \item Pointers in the C program needs to be transformed into signals instead of a memory location inside the memory controller. As there is only one module in the output Verilog, no point-to analysis is needed to decide what module the pointed variable will be used in. This will eliminate the need for the memory controller and global \gls{ram}s.
    \item The memory controller module, as well as all other unused, \gls{fpga} specific modules, need to be removed from the Verilog generation. Theses modules are not needed when there is no hybrid-flow, and pointers no longer are stored in global memory. The most important task is to ensure that the modules are not instantiated in the top module, but having multiple unused modules declared in the Verilog code clogs up the file with unnecessary lines, making it harder to detect actually important parts.
    \item A way to specify the bit-width of a signal must be implemented. Since no other sizes than 8, 16, 32, and 64 bits are supported by \gls{ansi}-C, new data-types have to be defined in C, or a way to set constraints on input/output signals must be added to LegUp.
\end{enumerate}

\subsubsection{Possible solutions}

There are two possible approaches in order to fix these problems:
\begin{itemize}
\item Post-processing of the Verilog generated by LegUp, in order to remove unwanted code and adapt the code into a format suitable for synthesis towards an \gls{asic} implementation.
\item Pre-processing, i.e. altering the LegUp and LLVM libraries that are used for compilation of the source code and Verilog generation, so that the output Verilog are synthesizable to \gls{asic} applications.
\end{itemize}

The post-processing solution is clearly the simplest alternative, as it only requires a parser that can loop through the code and remove or reformat code output. This alternative is however very uncertain with respect to the quality of results. The question is whether or not the Verilog contains enough information to transform it into the desirable format and still keep the correct functionality. The performance might also be a concern, as we will see below.

As an example, we can use the code described in \cref{lst:exampleCProgram} as a base. In the output Verilog code the input variables, inDataA and inDataB, are declared differently, as inDataA is declared as an int while inDataB is declared as a char-pointer in the C program. The output gives:
\lstset{language=Verilog, style=Verilogstyle}
\begin{lstlisting}
input [31:0] arg_inDataA;
input [`MEMORY_CONTROLLER_ADDR_SIZE-1:0] arg_inDataB;
\end{lstlisting}
Later in the Verilog code, the signal inDataA is used as a normal variable, but each time inDataB is used, the value of inDataB is assigned to the output \textit{memory\_controller\_add-ress\_a}, and in the next cycle, the data is sent from the memory controller to the input \textit{memory\_controller\_out\_a} of the \textit{main} module. In this case, the post-processor needs to change the declaration of \textit{inDataB} to be a signal in the circuit, rather than a connection to the memory controller:
\begin{lstlisting}
input [31:0] arg_inDataA;
input [31:0] arg_inDataB;
\end{lstlisting}
The parser also needs to modify the part of the code where the value of inDataB, gathered from the memory controller, is used in operations inside the main module. For instance, the following code snippet in the generated Verilog, assigning the value of inDataB from the memory controller (the commented line refers to the LLVM-\gls{ir}):
\begin{lstlisting}
/*   %36 = load i8** %inDataB, align 4*/
main_35_36 = memory_controller_out_a[`MEMORY_CONTROLLER_ADDR_SIZE-1:0];
\end{lstlisting}
should be changed to:
\begin{lstlisting}
/*   %36 = load i8** %inDataB, align 4*/
main_35_36 = arg_inDataB[31:0];
\end{lstlisting}
This simple example shows what needs to be changed in order to get the correct functionality. This is however not the only part that should be changed. Each access to a global memory takes two clock cycles \cite{leguparch}, meaning that the generated \gls{fsm} takes account for this delay. The delay will have to be eliminated in order to get the best performance out of the circuit. If it is not removed, and the user is not aware of the delay, input data might be lost.

The outcome of this is that the parser needs to account for a large amount of potential alterations in the output Verilog, making it a complex task to get everything correct.

Unless a way of setting constraints on input/output signals are added to LegUp, it is not likely that the parser is able to do anything with the potentially over-sized bit-widths of signals. If the widths of signals are set in a constraint file, the parser can easily change the widths of the signals in the output Verilog-file.

The alternative of altering the LegUp and LLVM libraries, offers much greater opportunities for you to get a functional and correct Verilog output. The downside of this alternative is that the LegUp libraries are quite large, and searching, understanding and altering large parts of the code can be time-consuming. 

A possible solution to the problem mentioned in \cref{item:futworkprob} in \cref{subsec:reqact} has been found. By adding the flag \textit{-ffreestanding} to the variable CLANG\_FLAG in the file Makefile.config of LegUp, the clang compiler frontend of LLVM will consider the C code to contain a freestanding - not a hosted - environment, and therefore not caring about what types of inputs and return values the \textit{main}-function has. This will allow multiple input arguments of any type. You will still be limited to one return variable, as C does not support multiple return values. The return value can be a struct, but due to the limited support for structs, it is not likely that LegUp splits the variables in the struct into multiple output signals in the generated Verilog. The alternative is to use pointers as input arguments, making it possible to get output variables as \textit{pass-by-reference} values. This will probably require major alterations to the LegUp libraries.   

Removing the memory controller from the LegUp libraries might be a complex operation, but it can actually be simpler than in the post-processing option. The libraries that detect if a signal or pointer, points to a single, multiple or unknown function(s), needs to be changed so all point to the \textit{main}-function. This point-to analysis is performed in the file \textit{Allocation.cpp}, and variables are added to local or global \gls{ram}s by the functions below, where \textit{ram} is a pointer to a \gls{ram} object and \textit{F} is a pointer to a function object:
\lstset{language=C,style=Cstyle}
\begin{lstlisting}
/* Adding Local RAM: */
addLocalRam(F, ram);
/* Making RAM global: */
addGlobalRam(ram);
\end{lstlisting}

The memory controller and \gls{fpga} specific modules that are no longer needed can easily be removed from the generated Verilog by removing the printing of the declarations and instantiations in the file \textit{VerilogWriter.cpp}.

\subsection{Optional tasks}

One of the questions raised in the motivation section in the introduction chapter was whether the incorporation of Nordic Semiconductor's \gls{ddvc} into the Verilog generating libraries of LegUp would reduce the generated overhead. As this was not an objective of this project, this extension should be performed in an continuation of the project.

When setting the constraint \textit{INFERRED\_RAMS}, as described in \cref{subsec:hlsreqconst}, the support for structs are lost. This constraint is needed since altsyncram modules are not supported by non-Altera devices. The support for structs are a strength in \gls{hll}-languages that can be useful in many cases when describing the circuit functionality in the C-code before \gls{hls}. According to \cite{legupconst} this lack of struct-support is due to that there is no byte-enable support in the inferred RAMs. Byte-enable means being able to write a single byte (8 bits) to the \gls{ram} instead of the full 32-bit word. To retrieve the support for structs, a generic \gls{ram} module with byte-enable support needs to be implemented in Verilog and incorporated into the LegUp libraries as an alternative to the inferred generic \gls{ram}s and the altsyncram. A template from the Quartus II software, implementing a true dual-port \gls{ram} with different read/write addresses, single read/write clock, and with a control for writing single bytes into the memory word; byte enable, is listed in \cref{sec:ramtempcode}.

The supported output from LegUp is currently limited to Verilog \gls{hdl}. Verilog still gets the job done, but many companies, including Nordic Semiconductor, have moved to SystemVerilog for their preferred design \gls{hdl}. SystemVerilog is the natural successor of Verilog, providing support for user-defined types, adding strong-typing capabilities (for user-defined types), extending capabilities of reuse functionality, greater testbench development, assertion-based verification, and interface abstraction and packaging \cite{bailey2003comparison}. In many cases, SystemVerilog use the same syntax as Verilog, and it should therefore be a simple and natural development to add support for generating SystemVerilog \gls{hdl} output in LegUp.

Another interesting topic is to look into the possibility of extending the basic testbench generated by LegUp, to include automatic generation of test-cases. As the functionality of the module is described in a \gls{hll}, it should be possible to utilize this model to generate a self-checking testbench. This will eliminate the need for writing a custom testbench for each design. A large amount of test-cases are needed for simulation, to provide a realistic \gls{vcd}-file to the power estimation tool. This task might be complex, but if implemented successfully it can decrease the total design-time of a module even further.