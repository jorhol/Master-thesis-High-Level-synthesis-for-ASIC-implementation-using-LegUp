\chapter{\label{chp:discussion}Discussion}

The framework has been created to be easily configurable if it is desirable to add other functionality. For this proof-of-concept, only constraints set on the HLS process in LegUp has been used. It could also be useful to add other parameters to the framework, to control other parts of the tool-flow. Examples could be to run synthesis using different clock-speeds, or to specify optimization goals, like minimum area or maximum speed, for synthesis and layout. This would generate an even wider pool of designs to choose from, increasing the chance of getting the very best design. The downside of including more parameters into the framework is the exponential increase in the number of designs and accompanying tool-flow run-time. If all possibilities of 50 different constraints, each having two possible values, should be explored, a total of $2^{50} = 1~125~899~906~842~624$ (over 1 quadrillion) designs would have to be run through the tool-flow. If the tool-flow used 1 minute to process each design, the run-time for the framework would end up at 2.142 billion years. In practice, the designer is therefore required to select a few parameters that he puts his belief in, and hope this gives one of the best possible results.

From the results given in \cref{sec:fullflowresults}, the best-case and worst-case design can be compared. A potential area saving of 50872.8523 and power sawing of 0.670 mW can be achieved, by selecting the best architecture over the worst. This corresponds to a saving in area of 13.28\% and a saving in power consumption of 9.52\%. Compared to the design written directly in Verilog, the best-case area is 282.69\% and power consumption is 299.81\% of the results achieved in the Verilog design. An overhead of 182.69\% and 199.81\% are not great results, but the idea here is not to get a comparable result, rather to show that the concept works and can be used for a framework for architectural exploration. This goal has been achieved, as we get varied outputs depending on the given HLS constraints. As seen in \cref{sec:codeoptimization}, the overhead generated by LegUp can be decreased greatly by optimizing the functional specification code. This gives an overhead of 31.57\% in terms of area and 42.02\% in terms of average power consumption. These numbers are much more in sync with the expected overhead of \gls{hls}-tools of 30-40\%. However, it would not always be this easy to see the potential optimizations that can be performed on the code. The same code were used in the design written directly in Verilog, but here synthesis realized that the excessive registers were obsolete and optimized them away. This same optimization could not be performed on the \gls{hls}-generated designs, as synthesis could not draw the same conclusion through the \gls{fsm} created by LegUp.

When looking at the speed of the generated designs compared to the design written in Verilog, there is a huge gap in the theoretical maximum frequency. This is a major drawback for the use of LegUp to produce hardware. There is also a second factor to the actual speed of the design. While the design written in Verilog use primarily combinational logic to generate the output, the \gls{hls}-generated design use a FSM. In the combinational circuit, the same operation is performed each clock-cycle, leading to the finished calculation of the FIR-filter being available at the output-port 16 clock cycles after the input was set. In the \gls{hls}-generated design, a total time of $47840ns$ is required after the input is applied before the output is ready. This corresponds to 2392 clock-cycles with the clock-period of $20ns$ used under simulation. The actual time needed for calculation is then:
\begin{equation*}
    Verilog: 3.07\frac{ns}{cycle}*16~cycles = 49.12ns
\end{equation*}

\begin{equation*}
    HLS: 50.80\frac{ns}{cycle}*2392~cycles = 121513.6ns
\end{equation*}

This means that the design written in Verilog is 2473.81 times as fast as the HLS-generated design when it comes to producing a valid output, if both are run at their maximum frequency. If both designs were run at the maximum frequency of the HLS-generated design, the Verilog-design would still be 149.5 times as fast as the HLS-generated design. Using the optimized code described in \cref{sec:codeoptimization}, a total of 1235 clock-cycles is required to produce the output. The Verilog-design would then still be 1277 times as fast as the HLS-generated design. If both were run at the maximum frequency of the HLS-generated design, the Verilog-design would still be 77 times as fast as the HLS-generated design.

Even though the desired proof-of-concept has been shown, the alterations done to LegUp to get Verilog-output suitable for ASIC implementation has put constraints on how the functional specification can be written and limited the use of many features of the higher level of abstraction in C. Originally the input were ANSI-C, supporting functions, arrays, structs, global variables, floating point, and pointers. When using this adapted version of LegUp for generating ASIC-compliant Verilog, only functions and partially arrays seem to work correctly. Especially the pointer-, and related array-support, should be working correctly for the tool to be useful. Most of these limitations can probably be overcome by altering the libraries further, but this will be time-consuming. One possible solution to bring some of these features back would be to re-introduce the \textit{top}-module that instantiates the \textit{main}-module and the \textit{memory\_controller}-module and connect all inputs and outputs directly to the ports of the \textit{main}-module in \textit{top}. This would work with the implementation of outputs from parameters and the streaming port feature. The downside of this approach is that the memory controller will bring back some extra overhead to the design. An alternative solution would be to further alter the libraries of LegUp, to make sure all RAMs are implemented as local RAMs. 

There are still some bugs originating from the implemented alterations to LegUp present in the designs. These bugs were not focused on during the work with this thesis, but is something that must be resolved it the framework should be able to generate functional results. It is also an element of concern that the way you write your functional specification can affect the generated designs greatly. The compiler or LegUp should be able to optimize away any parts of excess code.
