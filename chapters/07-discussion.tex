\chapter{\label{chp:discussion}Discussion}

The framework has been created to be easily configurable and adaptable if it is desirable to add other functionality. For this proof-of-concept, only constraints set on the HLS process in LegUp has been used. It could however be useful to add other parameters to the framework, to control other parts of the tool-flow. Examples could be to run synthesis using different clock-speeds, or to specify optimization goals, like minimum area or maximum speed, for synthesis and layout. This would generate an even wider pool of designs to decide from, increasing the chance of getting the very best design. The downside of including more parameters into the framework is the exponential increase in the number of designs and accompanying tool-flow run-time. If all possibilities of 50 different constraints, each having two possible values, should be explored, a total of $2^{50} = 1~125~899~906~842~624$ (over 1 quadrillion) designs would have to be run through the tool-flow. If the tool-flow used 1 minute to process each design, the run-time for the framework would end up at 2.142 billion years. In practice, the designer is therefore required to select a few parameters that he puts his belief in, and hope this gives one of the best possible results.

From the results given in \cref{sec:fullflowresults}, the best-case and worst-case design can be compared. A potential area saving of 50872.8523 and power sawing of 0.670 mW can be achieved, by selecting the best architecture over the worst. This corresponds to a saving in area of 13.28\% and a saving in power consumption of 9.52\%. Compared to the design written directly in Verilog, the best-case area is 282.69\% and power consumption is 299.81\% of the results achieved in the Verilog design. An overhead of 182.69\% and 199.81\% are not great results, but the idea here is not to get a comparable result, rather to show that the concept works and can be used for a framework for architectural exploration. This goal has been achieved, as we get varied outputs depending on the given HLS constraints. As seen in \cref{sec:codeoptimization}, the overhead generated by LegUp can be decreased greatly by optimizing the functional specification code. This gives an overhead of 31.57\% in terms of area and 42.02\% in terms of average power consumption. These numbers are much more in sync with the expected overhead of \gls{hls}-tools of 30-40\%. However, it would not always be this easy to see the potential optimizations that can be performed on the code. The same code were used in the design written directly in Verilog, but here synthesis realized that the excessive registers were obsolete and optimized them away. This same optimization could not be performed on the \gls{hls}-generated designs, as synthesis could not draw the same conclusion through the \gls{fsm} created by LegUp.

Even though the desired proof-of-concept has been shown, the alterations done to LegUp to get Verilog output suitable for ASIC implementation has put constraints on how the functional specification can be written and limited the use of many features of the higher level of abstraction in C. Originally the input were ANSI-C, supporting functions, arrays, structs, global variables, floating point, and pointers. When using this adaption of LegUp for generating ASIC-compliant Verilog, only functions and partially arrays seem to work correctly. Especially the pointer and related array-support should be working correctly for the tool to be useful. Most of these limitations can probably be overcome by altering the libraries further, but this will be time consuming. It is also an element of unease that the way you write your functional specification can affect the generated designs greatly. The compiler or LegUp should be able to optimize away any parts of the code that is obsolete. An alternative solution to bring some of these features back would be to re-introduce the top-module that instantiates the \textit{main}-module and the \textit{memory\_controller}-module and connect all inputs and outputs directly to the ports of the \textit{main}-module in top. This would work with the implementation of outputs from parameters and the streaming port feature. The downside of this approach is that the memory controller will bring back some extra overhead to the design. An alternative solution would be to further alter the libraries of LegUp, to make sure all RAMs are implemented as local RAMs. 

\section{Advances in LegUp since last release}
From the GIT repository of LegUp \cite{legupgit}, it can be seen that many new features have been, and still are being, implemented for the next release version of LegUp. The current version (4.0), were released in August 2015, and the normal release cycle of LegUp is one year. One of the more interesting features from the views of this project is the implementation of streaming inputs and outputs. Even though this has been implemented in this project as well, a native implementation from the developers can be more thoroughly tested and have more functionality than the one implemented here. However, it is still uncertain if a good way of producing multiple output-signals have been implemented. In another commit it is mentioned that it will be possible to mark a RAM as external, making it possible to pass pointers as arguments into the top-level function. These features are exciting news from the perspective of this thesis, as it can look like the developers implements more things useful for ASIC hardware development.