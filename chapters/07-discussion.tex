\chapter{Discussion}

The alterations done to LegUp to get Verilog output suitable for ASIC implementation has limited the use of many features of the higher level of abstraction in C. This put large constraints on how you can write your C-code if you want to run it through the framework. Especially the pointer and related array-support should be working. An alternative to bring these features back would be to re-introduce the top-module that instantiates the \textit{main}-module and the \textit{memory\_controller}- module and pass all inputs and outputs directly through the top and to the \textit{main}-module. This would work after the implementation of outputs from parameters and the streaming port feature. The downside of this approach is that the memory controller will bring back some extra overhead to the design. An alternative solution would be to further alter the libraries of LegUp, to make sure all RAMs are implemented as local RAMs. 

The framework has been created to be easily configurable and adaptable if it is desirable to add functionality. For this proof-of-concept, only constraints set on the HLS process in LegUp has been used. It could however be useful to add other parameters to the framework, to control other parts of the tool-flow. Examples could be to run synthesis using different clock-speeds, or to specify optimization goals, like minimum area or maximum speed, for synthesis and layout. This would generate an even wider pool of designs to decide from, increasing the chance of getting the very best design. The downside of including more parameters into the framework is the exponential increase in the number of designs and accompanying tool-flow run-time. If all possibilities of 50 different constraints, each having two possible values, should be explored, a total of $2^{50} = 1~125~899~906~842~624$ (over 1 quadrillion) designs would have to be run through the tool-flow. If the tool-flow used 1 minute to process each design, the run-time for the framework would end up at 2.142 billion years. In practice, the designer is therefore required to select a few parameters that he puts his belief in, and hope this gives one of the best possible results.

By comparing the best-case design towards the worst-case design, a potential area saving of 50872.8523 and power sawing of 0.670 mW is achieved. This corresponds to a decrease in area of 13.28\% and a decrease in power consumption of 9.52\%. Compared to the design written directly in Verilog, the best-case area is 282.69\% and power consumption is 331.34\% of the results achieved in the Verilog design. An overhead of almost 200\% is not a great result, but the idea here is not to get a comparable result, rather to show that the concept works and can be used for a framework for architectural exploration. This goal has been achieved, as we get varied outputs depending on the given HLS constraints.

Even though the desired proof-of-concept has been shown, the changes made to LegUp to achieve a acceptable Verilog output suitable for ASIC implementation, has generated many limitations and special cases with regards to how the functional specification can be written. Originally the input were ANSI-C, supporting functions, arrays, structs, global variables, floating point, and pointers. When using this adaption of LegUp for generating ASIC-compliant Verilog, only functions and partially arrays seem to work correctly. Most of these limitations can probably be overcome by altering the libraries further, but this will be time consuming.

\section{Advances in LegUp since last release}
From the GIT repository of LegUp, it can be seen that many new features have been and still are being implemented for the next release version of LegUp. The current version (4.0), were released in August 2015. One of the more interesting features from the views of this project is the implementation of streaming inputs and outputs. Even though this has been implemented in this project as well, a native implementation from the developers can be more thoroughly tested and have more functionality than the one implemented here. However, it is still uncertain if a good way of producing multiple output-signals have been implemented. In another commit it is mentioned that it will be possible to mark a RAM as external, making it possible to pass pointers as arguments into the top-level function. These features are exciting news from the perspective of this thesis, as it can look like the developers implements more things useful for ASIC hardware development.